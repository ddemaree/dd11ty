---
import { Markdown } from "astro/components";
import { getCloudinaryImageInfo, getImageUrl, getLQIP } from '../lib/cloudinary';

export interface ImageProps {
  cloudinary?: string,
  src: string,
  alt?: string,
  caption?: string,
  size?: 'wide' | 'full',
  style?: any
};

const { src, alt, caption, size, style } = Astro.props as ImageProps;

const { width, height } = await getCloudinaryImageInfo(src);
// const lqipSrc = getLQIP(src);
const assetURL = getImageUrl(src);

const svgPlaceholder = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzODQwIiBoZWlnaHQ9IjIxNjAiPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiPjxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwiIHZhbHVlcz0icmdiYSgxNTMsMTUzLDE1MywwLjUpO3JnYmEoMTUzLDE1MywxNTMsMC4xKTtyZ2JhKDE1MywxNTMsMTUzLDAuNSkiIGR1cj0iMnMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiAvPjwvcmVjdD48L3N2Zz4=";

const hasCaptionSlot = Astro.slots.has('default')

---
<figure class:list={['dd-image', (size && `size-${size}`)]} {style}>
  <img loading="lazy" class="img img-preload" src={svgPlaceholder} {width} {height} {alt} data-src={assetURL} />
  <noscript><img src={assetURL} /></noscript>
  {caption && <figcaption><Markdown content={caption} /></figcaption>}
  {hasCaptionSlot && <figcaption><slot /></figcaption>}
</figure>

<style is:global>
@keyframes reveal {
  0% {
    transform: scale(1.05);
    opacity: 0;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.img {
  border: 0;
  outline: none;
}
.img-preload {
  background-color: var(--theme-bg-offset);
}

.img-wrap {
  overflow: hidden;
  position: relative;
  width: max-content;
  max-width: 100%;

  > img {
    display: block;
    left: 0;
    top: 0;
  }

  .img-preload {
    filter: blur(2vw);
    transform: scale(1.05);
  }

  .img-full {
    will-change: transform, opacity;
    animation: reveal 0.5s ease-out;
    position: absolute;
  }
}
</style>

<script>
  function loadImage(img) {
    const wrapper = img.closest(".img-wrap");
    const fullSrc = img.dataset.src;

    const fullImg = new Image();
    const imgClasses = ["img-full", ...img.classList].filter(
      (c) => c !== "img-preload"
    );
    fullImg.classList.add(...imgClasses);

    fullImg.src = fullSrc;
    fullImg.width = img.attributes["width"]
      ? img.attributes["width"].value
      : img.width;

    fullImg.height = img.attributes["height"]
      ? img.attributes["height"].value
      : img.height;

    if (img.alt) fullImg.alt = img.alt || "";
    if (img.dataset.srcset) fullImg.srcset = img.dataset.srcset;

    const addImage = () => {
      setTimeout(function() {
        wrapper.appendChild(fullImg).addEventListener("animationend", (e) => {
          const preview = wrapper.querySelector(".img-preload");
          if (preview) wrapper.removeChild(preview);
          e.target.classList.remove("img-full");
        });
      }, 150);
    };

    if (fullImg.complete) addImage();
    else fullImg.onload = addImage;
  }

  const config = {
    rootMargin: "0px 0px 0px 0px",
    threshold: 0,
  };

  let observer = new IntersectionObserver((entries, self) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        loadImage(entry.target);
      }
    });
  }, config);

  window.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('.img').forEach(img => {
      let wrapper = img.closest('.img-wrap')
      if(!wrapper) {
        wrapper = document.createElement("div");
        wrapper.classList.add("img-wrap");
        img.parentNode.insertBefore(wrapper, img);
        wrapper.appendChild(img);
      }

      observer.observe(img);
    })
  });
</script>